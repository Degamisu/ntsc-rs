use core::slice;
use std::ffi::CString;
use std::ptr::addr_of;
use std::{ffi::c_char, mem::ManuallyDrop, ptr};

use ntscrs::{ntsc::NtscEffect, yiq_fielding::YiqView};
use ntscrs::settings::{
    NtscEffectFullSettings, SettingDescriptor as RsSettingDescriptor,
    SettingID as RsSettingID, SettingKind as RsSettingKind, SettingsList as RsSettingsList,
};
use ntscrs::{FromPrimitive, ToPrimitive};

#[repr(C)]
/// Represents a menu item in the Enumeration setting type.
pub struct MenuItem {
    /// The menu item's text label. Always present.
    label: *mut c_char,
    /// Length in *bytes* of the text label, not including the final null terminator.
    label_len: usize,
    /// The menu item's description/tooltip. May be null.
    description: *mut c_char,
    /// Length in bytes of the description.
    description_len: usize,
    /// The enum index that this item belongs to. May not be the same as its position in the menu!
    index: u32,
}

#[repr(C)]
pub enum SettingKind {
    Enumeration {
        options: *mut MenuItem,
        len: usize,
        default_value: u32,
    },
    Percentage {
        logarithmic: bool,
        default_value: f32,
    },
    IntRange {
        min: i32,
        max: i32,
        default_value: i32,
    },
    FloatRange {
        min: f32,
        max: f32,
        logarithmic: bool,
        default_value: f32,
    },
    Boolean {
        default_value: bool,
    },
    Group {
        children: *mut SettingDescriptor,
        len: usize,
        default_value: bool,
    },
}

#[repr(C)]
pub struct SettingDescriptor {
    label: *mut c_char,
    label_len: usize,
    description: *mut c_char,
    description_len: usize,
    kind: SettingKind,
    /// Unique ID for this setting. This will not change and will not be reused if settings are removed.
    id: u32,
}

// NtscEffectFullSettings is generated by a derive macro, so cbindgen can't "see" it, even if just to generate an
// opaque struct definition for it. Wrap it in another opaque struct which cbindgen can see.
pub struct Configurator(NtscEffectFullSettings);

impl Configurator {
    #[no_mangle]
    pub extern "C" fn ntscrs_configurator_create() -> *mut Configurator {
        Box::into_raw(Box::new(Configurator(NtscEffectFullSettings::default())))
    }

    #[no_mangle]
    pub unsafe extern "C" fn ntscrs_configurator_free(configurator_ptr: *mut Configurator) {
        let configurator = Box::from_raw(configurator_ptr);
        drop(configurator);
    }

    #[no_mangle]
    pub extern "C" fn ntscrs_settings_set_field_float(&mut self, id: u32, value: f32) {
        let id = RsSettingID::from_u32(id).unwrap();
        if let Some(field_ref) = id.get_field_mut::<f32>(&mut self.0) {
            *field_ref = value;
        }
    }

    #[no_mangle]
    pub extern "C" fn ntscrs_settings_set_field_int(&mut self, id: u32, value: i32) {
        let id = RsSettingID::from_u32(id).unwrap();
        if let Some(field_ref) = id.get_field_mut::<i32>(&mut self.0) {
            *field_ref = value;
        } else if let Some(field_ref) = id.get_field_mut::<u32>(&mut self.0) {
            *field_ref = value as u32;
        } else {
            id.set_field_enum(&mut self.0, value as u32).unwrap();
        }
    }

    #[no_mangle]
    pub extern "C" fn ntscrs_settings_set_field_bool(&mut self, id: u32, value: bool) {
        let id = RsSettingID::from_u32(id).unwrap();
        if let Some(field_ref) = id.get_field_mut::<bool>(&mut self.0) {
            *field_ref = value;
        }
    }

    #[no_mangle]
    pub extern "C" fn ntscrs_settings_get_field_float(&mut self, id: u32) -> f32 {
        let rs_id = RsSettingID::from_u32(id).unwrap();
        match rs_id.get_field_mut::<f32>(&mut self.0) {
            Some(value) => *value,
            None => panic!("Descriptor field {id} is invalid or not a float"),
        }
    }

    #[no_mangle]
    pub extern "C" fn ntscrs_settings_get_field_int(&mut self, id: u32) -> i32 {
        let rs_id = RsSettingID::from_u32(id).unwrap();
        if let Some(field_ref) = rs_id.get_field_mut::<i32>(&mut self.0) {
            *field_ref
        } else if let Some(field_ref) = rs_id.get_field_mut::<u32>(&mut self.0) {
            *field_ref as i32
        } else if let Some(enum_value) = rs_id.get_field_enum(&self.0) {
            enum_value as i32
        } else {
            panic!("Descriptor field {id} is invalid or not a u32, i32, or enum")
        }
    }

    #[no_mangle]
    pub extern "C" fn ntscrs_settings_get_field_bool(&mut self, id: u32) -> bool {
        let rs_id = RsSettingID::from_u32(id).unwrap();
        match rs_id.get_field_mut::<bool>(&mut self.0) {
            Some(value) => *value,
            None => panic!("Descriptor field {id} is invalid or not a bool"),
        }
    }
}

fn descriptors_to_c(descs: &[RsSettingDescriptor]) -> (*mut SettingDescriptor, usize, usize) {
    let mut c_settings = Vec::<SettingDescriptor>::new();

    let mut num_group_children  = 0;

    for setting in descs {
        let c_desc = SettingDescriptor {
            label: CString::new(setting.label).unwrap().into_raw(),
            label_len: setting.label.len(),
            description: match setting.description {
                Some(desc) => CString::new(desc).unwrap().into_raw(),
                None => ptr::null_mut(),
            },
            description_len: match setting.description {
                Some(desc) => desc.len(),
                None => 0,
            },
            kind: match &setting.kind {
                RsSettingKind::Enumeration {
                    options,
                    default_value,
                } => {
                    let mut c_options = Vec::<MenuItem>::new();
                    for option in options {
                        c_options.push(MenuItem {
                            label: CString::new(option.label).unwrap().into_raw(),
                            label_len: option.label.len(),
                            description: match option.description {
                                Some(desc) => CString::new(desc).unwrap().into_raw(),
                                None => ptr::null_mut(),
                            },
                            description_len: match option.description {
                                Some(desc) => desc.len(),
                                None => 0,
                            },
                            index: option.index,
                        });
                    }
                    SettingKind::Enumeration {
                        options: ManuallyDrop::new(c_options.into_boxed_slice()).as_mut_ptr(),
                        len: options.len(),
                        default_value: *default_value,
                    }
                }
                RsSettingKind::Percentage {
                    logarithmic,
                    default_value,
                } => SettingKind::Percentage {
                    logarithmic: *logarithmic,
                    default_value: *default_value,
                },
                RsSettingKind::IntRange {
                    range,
                    default_value,
                } => SettingKind::IntRange {
                    min: *range.start(),
                    max: *range.end(),
                    default_value: *default_value,
                },
                RsSettingKind::FloatRange {
                    range,
                    logarithmic,
                    default_value,
                } => SettingKind::FloatRange {
                    min: *range.start(),
                    max: *range.end(),
                    logarithmic: *logarithmic,
                    default_value: *default_value,
                },
                RsSettingKind::Boolean { default_value } => SettingKind::Boolean {
                    default_value: *default_value,
                },
                RsSettingKind::Group {
                    children,
                    default_value,
                } => {
                    let (c_children, len, traversed_group_children) = descriptors_to_c(children);
                    num_group_children += traversed_group_children;
                    SettingKind::Group {
                        children: c_children,
                        len,
                        default_value: *default_value,
                    }
                }
            },
            id: setting.id.to_u32().unwrap(),
        };
        c_settings.push(c_desc);
    }

    let mut p = ManuallyDrop::new(c_settings.into_boxed_slice());

    for i in 0..p.len() {
        let addr = addr_of!(p[i]);
        println!("element {i} has address {addr:?}");
    }

    (p.as_mut_ptr(), descs.len(), descs.len() + num_group_children)
}

#[repr(transparent)]
struct DescriptorsById(Box<[Option<Box<[usize]>>]>);

#[repr(C)]
pub struct SettingsList {
    descriptors: *const SettingDescriptor,
    len: usize,
    total_num_settings: usize,
    by_id: *const DescriptorsById,
}

impl SettingsList {
    #[no_mangle]
    pub extern "C" fn ntscrs_settingslist_create() -> Self {
        let settings = RsSettingsList::new();
        let (descriptors, len, total_num_params) = descriptors_to_c(&settings.settings);
        SettingsList { descriptors, len, total_num_settings: total_num_params, by_id: Box::into_raw(Box::new(DescriptorsById(settings.by_id))) }
    }

    #[no_mangle]
    pub unsafe extern "C" fn ntscrs_settingslist_free(self) {
        let mut drop_stack: Vec<&[SettingDescriptor]> = Vec::new();

        let descs_slice = slice::from_raw_parts(self.descriptors, self.len);
        drop_stack.push(descs_slice);
        while let Some(descriptors) = drop_stack.pop() {
            
            for descriptor in descriptors {
                match descriptor.kind {
                    SettingKind::Enumeration {
                        options,
                        len,
                        default_value: _,
                    } => {
                        let s = slice::from_raw_parts_mut(options, len);
                        let b = Box::<[MenuItem]>::from_raw(s);

                        for item in s {
                            let label = CString::from_raw(item.label);
                            drop(label);
                            if item.description != ptr::null_mut() {
                                let description = CString::from_raw(item.description);
                                drop(description);
                            }
                        }
                        drop(b);
                    }
                    SettingKind::Group {
                        children,
                        len,
                        default_value: _,
                    } => {
                        let b = Box::<[SettingDescriptor]>::from_raw(slice::from_raw_parts_mut(
                            children, len,
                        ));
                        drop(b);
                    }
                    _ => {}
                }

                let label = CString::from_raw(descriptor.label);
                drop(label);
                if descriptor.description != ptr::null_mut() {
                    let description = CString::from_raw(descriptor.description);
                    drop(description);
                }
            }
        }
    }

    #[no_mangle]
    pub extern "C" fn ntscrs_settingslist_get_descriptor_by_id(&self, id: u32) -> *const SettingDescriptor {
        unsafe {
            let by_id = &(*self.by_id).0;

            let id = id as usize;
            if id >= by_id.len() {
                return ptr::null();
            }

            let id_path = by_id[id].as_ref();
            if let Some(id_path) = id_path {
                let mut descs = self.descriptors;
                let mut desc: Option<&SettingDescriptor> = None;
                for (iter_index, descriptor_index) in id_path.iter().enumerate() {
                    let cur_desc = &*descs.add(*descriptor_index);
                    desc = Some(cur_desc);
                    match cur_desc.kind {
                        SettingKind::Group { children, .. } => {
                            descs = children;
                        },
                        _ => {
                            if iter_index != id_path.len() - 1 {
                                panic!("Tried to iterate into a descriptor that isn't a Group")
                            }
                        }
                    }
                }

                if let Some(desc) = desc {
                    desc
                } else {
                    panic!("Path was empty")
                }
            } else {
                ptr::null()
            }
        }
    }
}

#[no_mangle]
pub unsafe extern "C" fn ntscrs_process_yiq(
    y: *mut f32,
    i: *mut f32,
    q: *mut f32,
    width: usize,
    height: usize,
    settings: &Configurator,
    frame_num: usize,
) {
    let len = width * height;
    let mut yiq = YiqView {
        y: slice::from_raw_parts_mut(y, len),
        i: slice::from_raw_parts_mut(i, len),
        q: slice::from_raw_parts_mut(q, len),
        dimensions: (width, height),
        field: ntscrs::yiq_fielding::YiqField::Both,
    };
    NtscEffect::from(&settings.0).apply_effect_to_yiq(&mut yiq, frame_num);
}
