use core::slice;
use std::convert::identity;
use std::ffi::CString;
use std::mem::{self, MaybeUninit};
use std::{ffi::c_char, mem::ManuallyDrop, ptr};

use ntscrs::settings::{
    NtscEffectFullSettings, SettingDescriptor as RsSettingDescriptor, SettingID as RsSettingID,
    SettingKind as RsSettingKind, SettingsList as RsSettingsList,
};
pub use ntscrs::yiq_fielding::{BlitInfo as RsBlitInfo, Rect as RsRect};
use ntscrs::yiq_fielding::{DeinterlaceMode, PixelFormat, Xrgb16s, Xrgb32f, Xrgb8};
use ntscrs::{
    ntsc::NtscEffect,
    yiq_fielding::{YiqField as RsYiqField, YiqView},
};
use ntscrs::{FromPrimitive, ToPrimitive};

#[repr(C)]
pub enum YiqField {
    Upper,
    Lower,
    Both,
    InterleavedUpper,
    InterleavedLower,
}

impl From<&YiqField> for RsYiqField {
    fn from(value: &YiqField) -> Self {
        match value {
            YiqField::Upper => RsYiqField::Upper,
            YiqField::Lower => RsYiqField::Lower,
            YiqField::Both => RsYiqField::Both,
            YiqField::InterleavedUpper => RsYiqField::InterleavedUpper,
            YiqField::InterleavedLower => RsYiqField::InterleavedLower,
        }
    }
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
#[repr(C)]
pub struct Rect {
    pub top: usize,
    pub right: usize,
    pub bottom: usize,
    pub left: usize,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
#[repr(C)]
pub struct BlitInfo {
    /// The rectangular area which will be read out of or written into the other buffer.
    pub rect: Rect,
    /// Number of bytes per pixel row in the other buffer. May include padding.
    pub row_bytes: usize,
    /// True if the source buffer is y-up instead of y-down.
    pub flip_y: bool,
}

impl From<&Rect> for RsRect {
    fn from(value: &Rect) -> Self {
        Self {
            top: value.top,
            right: value.right,
            bottom: value.bottom,
            left: value.left,
        }
    }
}

impl From<&BlitInfo> for RsBlitInfo {
    fn from(value: &BlitInfo) -> Self {
        RsBlitInfo {
            rect: (&value.rect).into(),
            row_bytes: value.row_bytes,
            flip_y: value.flip_y,
        }
    }
}

#[repr(C)]
/// Represents a menu item in the Enumeration setting type.
pub struct MenuItem {
    /// The menu item's text label. Always present.
    label: *mut c_char,
    /// Length in *bytes* of the text label, not including the final null terminator.
    label_len: usize,
    /// The menu item's description/tooltip. May be null.
    description: *mut c_char,
    /// Length in bytes of the description.
    description_len: usize,
    /// The enum index that this item belongs to. May not be the same as its position in the menu!
    index: u32,
}

#[repr(C)]
pub enum SettingKind {
    Enumeration {
        options: *mut MenuItem,
        len: usize,
        default_value: u32,
    },
    Percentage {
        logarithmic: bool,
        default_value: f32,
    },
    IntRange {
        min: i32,
        max: i32,
        default_value: i32,
    },
    FloatRange {
        min: f32,
        max: f32,
        logarithmic: bool,
        default_value: f32,
    },
    Boolean {
        default_value: bool,
    },
    Group {
        children: *mut SettingDescriptor,
        len: usize,
        default_value: bool,
    },
}

#[repr(C)]
pub struct SettingDescriptor {
    label: *mut c_char,
    label_len: usize,
    description: *mut c_char,
    description_len: usize,
    kind: SettingKind,
    /// Unique ID for this setting. This will not change and will not be reused if settings are removed.
    id: u32,
}

// NtscEffectFullSettings is generated by a derive macro, so cbindgen can't "see" it, even if just to generate an
// opaque struct definition for it. Wrap it in another opaque struct which cbindgen can see.
pub struct Configurator(NtscEffectFullSettings);

impl Configurator {
    #[no_mangle]
    pub extern "C" fn ntscrs_configurator_create() -> *mut Configurator {
        Box::into_raw(Box::new(Configurator(NtscEffectFullSettings::default())))
    }

    #[no_mangle]
    /// # Safety
    ///
    /// The pointer must be valid and must not have been freed.
    pub unsafe extern "C" fn ntscrs_configurator_free(configurator_ptr: *mut Configurator) {
        let configurator = Box::from_raw(configurator_ptr);
        drop(configurator);
    }

    #[no_mangle]
    pub extern "C" fn ntscrs_settings_set_field_float(&mut self, id: u32, value: f32) {
        let id = RsSettingID::from_u32(id).unwrap();
        if let Some(field_ref) = id.get_field_mut::<f32>(&mut self.0) {
            *field_ref = value;
        }
    }

    #[no_mangle]
    pub extern "C" fn ntscrs_settings_set_field_int(&mut self, id: u32, value: i32) {
        let id = RsSettingID::from_u32(id).unwrap();
        if let Some(field_ref) = id.get_field_mut::<i32>(&mut self.0) {
            *field_ref = value;
        } else if let Some(field_ref) = id.get_field_mut::<u32>(&mut self.0) {
            *field_ref = value as u32;
        } else {
            id.set_field_enum(&mut self.0, value as u32).unwrap();
        }
    }

    #[no_mangle]
    pub extern "C" fn ntscrs_settings_set_field_bool(&mut self, id: u32, value: bool) {
        let id = RsSettingID::from_u32(id).unwrap();
        if let Some(field_ref) = id.get_field_mut::<bool>(&mut self.0) {
            *field_ref = value;
        }
    }

    #[no_mangle]
    pub extern "C" fn ntscrs_settings_get_field_float(&mut self, id: u32) -> f32 {
        let rs_id = RsSettingID::from_u32(id).unwrap();
        match rs_id.get_field_mut::<f32>(&mut self.0) {
            Some(value) => *value,
            None => panic!("Descriptor field {id} is invalid or not a float"),
        }
    }

    #[no_mangle]
    pub extern "C" fn ntscrs_settings_get_field_int(&mut self, id: u32) -> i32 {
        let rs_id = RsSettingID::from_u32(id).unwrap();
        if let Some(field_ref) = rs_id.get_field_mut::<i32>(&mut self.0) {
            *field_ref
        } else if let Some(field_ref) = rs_id.get_field_mut::<u32>(&mut self.0) {
            *field_ref as i32
        } else if let Some(enum_value) = rs_id.get_field_enum(&self.0) {
            enum_value as i32
        } else {
            panic!("Descriptor field {id} is invalid or not a u32, i32, or enum")
        }
    }

    #[no_mangle]
    pub extern "C" fn ntscrs_settings_get_field_bool(&mut self, id: u32) -> bool {
        let rs_id = RsSettingID::from_u32(id).unwrap();
        match rs_id.get_field_mut::<bool>(&mut self.0) {
            Some(value) => *value,
            None => panic!("Descriptor field {id} is invalid or not a bool"),
        }
    }
}

fn descriptors_to_c(descs: &[RsSettingDescriptor]) -> (*mut SettingDescriptor, usize, usize) {
    let mut c_settings = Vec::<SettingDescriptor>::new();

    let mut num_group_children = 0;

    for setting in descs {
        let c_desc = SettingDescriptor {
            label: CString::new(setting.label).unwrap().into_raw(),
            label_len: setting.label.len(),
            description: match setting.description {
                Some(desc) => CString::new(desc).unwrap().into_raw(),
                None => ptr::null_mut(),
            },
            description_len: match setting.description {
                Some(desc) => desc.len(),
                None => 0,
            },
            kind: match &setting.kind {
                RsSettingKind::Enumeration {
                    options,
                    default_value,
                } => {
                    let mut c_options = Vec::<MenuItem>::new();
                    for option in options {
                        c_options.push(MenuItem {
                            label: CString::new(option.label).unwrap().into_raw(),
                            label_len: option.label.len(),
                            description: match option.description {
                                Some(desc) => CString::new(desc).unwrap().into_raw(),
                                None => ptr::null_mut(),
                            },
                            description_len: match option.description {
                                Some(desc) => desc.len(),
                                None => 0,
                            },
                            index: option.index,
                        });
                    }
                    SettingKind::Enumeration {
                        options: ManuallyDrop::new(c_options.into_boxed_slice()).as_mut_ptr(),
                        len: options.len(),
                        default_value: *default_value,
                    }
                }
                RsSettingKind::Percentage {
                    logarithmic,
                    default_value,
                } => SettingKind::Percentage {
                    logarithmic: *logarithmic,
                    default_value: *default_value,
                },
                RsSettingKind::IntRange {
                    range,
                    default_value,
                } => SettingKind::IntRange {
                    min: *range.start(),
                    max: *range.end(),
                    default_value: *default_value,
                },
                RsSettingKind::FloatRange {
                    range,
                    logarithmic,
                    default_value,
                } => SettingKind::FloatRange {
                    min: *range.start(),
                    max: *range.end(),
                    logarithmic: *logarithmic,
                    default_value: *default_value,
                },
                RsSettingKind::Boolean { default_value } => SettingKind::Boolean {
                    default_value: *default_value,
                },
                RsSettingKind::Group {
                    children,
                    default_value,
                } => {
                    let (c_children, len, traversed_group_children) = descriptors_to_c(children);
                    num_group_children += traversed_group_children;
                    SettingKind::Group {
                        children: c_children,
                        len,
                        default_value: *default_value,
                    }
                }
            },
            id: setting.id.to_u32().unwrap(),
        };
        c_settings.push(c_desc);
    }

    let mut p = ManuallyDrop::new(c_settings.into_boxed_slice());

    (
        p.as_mut_ptr(),
        descs.len(),
        descs.len() + num_group_children,
    )
}

#[repr(transparent)]
struct DescriptorsById(Box<[Option<Box<[usize]>>]>);

#[repr(C)]
pub struct SettingsList {
    descriptors: *const SettingDescriptor,
    len: usize,
    total_num_settings: usize,
    by_id: *const DescriptorsById,
}

impl SettingsList {
    #[no_mangle]
    pub extern "C" fn ntscrs_settingslist_create() -> Self {
        let settings = RsSettingsList::new();
        let (descriptors, len, total_num_params) = descriptors_to_c(&settings.settings);
        SettingsList {
            descriptors,
            len,
            total_num_settings: total_num_params,
            by_id: Box::into_raw(Box::new(DescriptorsById(settings.by_id))),
        }
    }

    #[no_mangle]
    /// # Safety
    ///
    /// The pointer must be valid and must not have been freed.
    pub unsafe extern "C" fn ntscrs_settingslist_free(self) {
        let mut drop_stack: Vec<&[SettingDescriptor]> = Vec::new();

        let descs_slice = slice::from_raw_parts(self.descriptors, self.len);
        drop_stack.push(descs_slice);
        while let Some(descriptors) = drop_stack.pop() {
            for descriptor in descriptors {
                match descriptor.kind {
                    SettingKind::Enumeration {
                        options,
                        len,
                        default_value: _,
                    } => {
                        let s = slice::from_raw_parts_mut(options, len);
                        let b = Box::<[MenuItem]>::from_raw(s);

                        for item in s {
                            let label = CString::from_raw(item.label);
                            drop(label);
                            if !item.description.is_null() {
                                let description = CString::from_raw(item.description);
                                drop(description);
                            }
                        }
                        drop(b);
                    }
                    SettingKind::Group {
                        children,
                        len,
                        default_value: _,
                    } => {
                        let b = Box::<[SettingDescriptor]>::from_raw(slice::from_raw_parts_mut(
                            children, len,
                        ));
                        drop(b);
                    }
                    _ => {}
                }

                let label = CString::from_raw(descriptor.label);
                drop(label);
                if !descriptor.description.is_null() {
                    let description = CString::from_raw(descriptor.description);
                    drop(description);
                }
            }
        }
    }

    #[no_mangle]
    pub extern "C" fn ntscrs_settingslist_get_descriptor_by_id(
        &self,
        id: u32,
    ) -> *const SettingDescriptor {
        unsafe {
            let by_id = &(*self.by_id).0;

            let id = id as usize;
            if id >= by_id.len() {
                return ptr::null();
            }

            let id_path = by_id[id].as_ref();
            if let Some(id_path) = id_path {
                let mut descs = self.descriptors;
                let mut desc: Option<&SettingDescriptor> = None;
                for (iter_index, descriptor_index) in id_path.iter().enumerate() {
                    let cur_desc = &*descs.add(*descriptor_index);
                    desc = Some(cur_desc);
                    match cur_desc.kind {
                        SettingKind::Group { children, .. } => {
                            descs = children;
                        }
                        _ => {
                            if iter_index != id_path.len() - 1 {
                                panic!("Tried to iterate into a descriptor that isn't a Group")
                            }
                        }
                    }
                }

                if let Some(desc) = desc {
                    desc
                } else {
                    panic!("Path was empty")
                }
            } else {
                ptr::null()
            }
        }
    }
}

#[no_mangle]
/// # Safety
///
/// The `y`, `i`, and `q` arguments must be valid pointers into arrays of `width` * `height` if the `settings` says to
/// process every field, or `width` * `height` / 2 if the `settings` says to process every other field.
pub unsafe extern "C" fn ntscrs_process_yiq(
    y: *mut f32,
    i: *mut f32,
    q: *mut f32,
    num_rows: usize,
    width: usize,
    height: usize,
    settings: &Configurator,
    frame_num: usize,
    field: YiqField,
) {
    let len = width * num_rows;
    let mut yiq = YiqView {
        y: slice::from_raw_parts_mut(y, len),
        i: slice::from_raw_parts_mut(i, len),
        q: slice::from_raw_parts_mut(q, len),
        dimensions: (width, height),
        field: (&field).into(),
    };
    NtscEffect::from(&settings.0).apply_effect_to_yiq(&mut yiq, frame_num);
}

unsafe fn yiq_set_from_strided_buffer_generic<S: PixelFormat>(
    src_data: *mut S::DataFormat,
    dst_yiq: *mut f32,
    blit_info: BlitInfo,
    width: usize,
    height: usize,
    field: YiqField,
) {
    let num_rows = RsYiqField::from(&field).num_image_rows(height);
    let len = width * num_rows;
    let (y, iq) = slice::from_raw_parts_mut(dst_yiq, len * 3).split_at_mut(len);
    let (i, q) = iq.split_at_mut(len);
    let mut yiq = YiqView {
        y,
        i,
        q,
        dimensions: (width, height),
        field: (&field).into(),
    };
    yiq.set_from_strided_buffer_maybe_uninit::<S, _>(
        slice::from_raw_parts_mut(
            src_data as *mut MaybeUninit<S::DataFormat>,
            blit_info.row_bytes / mem::size_of::<S::DataFormat>() * height,
        ),
        (&blit_info).into(),
        identity,
    )
}

unsafe fn ntscrs_yiq_write_to_strided_buffer_generic<S: PixelFormat>(
    src_yiq: *mut f32,
    dst_data: *mut S::DataFormat,
    blit_info: BlitInfo,
    width: usize,
    height: usize,
    field: YiqField,
) {
    let num_rows = RsYiqField::from(&field).num_image_rows(height);
    let len = width * num_rows;
    let (y, iq) = slice::from_raw_parts_mut(src_yiq, len * 3).split_at_mut(len);
    let (i, q) = iq.split_at_mut(len);
    let yiq = YiqView {
        y,
        i,
        q,
        dimensions: (width, height),
        field: (&field).into(),
    };
    yiq.write_to_strided_buffer_maybe_uninit::<S, _>(
        slice::from_raw_parts_mut(
            dst_data as *mut MaybeUninit<S::DataFormat>,
            blit_info.row_bytes / mem::size_of::<S::DataFormat>() * height,
        ),
        (&blit_info).into(),
        DeinterlaceMode::Bob,
        true,
        identity,
    )
}

#[no_mangle]
pub unsafe extern "C" fn ntscrs_yiq_set_from_strided_buffer_Xrgb32f(
    src_data: *mut f32,
    dst_yiq: *mut f32,
    blit_info: BlitInfo,
    width: usize,
    height: usize,
    field: YiqField,
) {
    yiq_set_from_strided_buffer_generic::<Xrgb32f>(
        src_data, dst_yiq, blit_info, width, height, field,
    )
}

#[no_mangle]
pub unsafe extern "C" fn ntscrs_yiq_set_from_strided_buffer_Xrgb16s(
    src_data: *mut i16,
    dst_yiq: *mut f32,
    blit_info: BlitInfo,
    width: usize,
    height: usize,
    field: YiqField,
) {
    yiq_set_from_strided_buffer_generic::<Xrgb16s>(
        src_data, dst_yiq, blit_info, width, height, field,
    )
}

#[no_mangle]
pub unsafe extern "C" fn ntscrs_yiq_set_from_strided_buffer_Xrgb8(
    src_data: *mut u8,
    dst_yiq: *mut f32,
    blit_info: BlitInfo,
    width: usize,
    height: usize,
    field: YiqField,
) {
    yiq_set_from_strided_buffer_generic::<Xrgb8>(src_data, dst_yiq, blit_info, width, height, field)
}

#[no_mangle]
pub unsafe extern "C" fn ntscrs_yiq_write_to_strided_buffer_Xrgb32f(
    src_yiq: *mut f32,
    dst_data: *mut f32,
    blit_info: BlitInfo,
    width: usize,
    height: usize,
    field: YiqField,
) {
    ntscrs_yiq_write_to_strided_buffer_generic::<Xrgb32f>(
        src_yiq, dst_data, blit_info, width, height, field,
    )
}

#[no_mangle]
pub unsafe extern "C" fn ntscrs_yiq_write_to_strided_buffer_Xrgb16s(
    src_yiq: *mut f32,
    dst_data: *mut i16,
    blit_info: BlitInfo,
    width: usize,
    height: usize,
    field: YiqField,
) {
    ntscrs_yiq_write_to_strided_buffer_generic::<Xrgb16s>(
        src_yiq, dst_data, blit_info, width, height, field,
    )
}

#[no_mangle]
pub unsafe extern "C" fn ntscrs_yiq_write_to_strided_buffer_Xrgb8(
    src_yiq: *mut f32,
    dst_data: *mut u8,
    blit_info: BlitInfo,
    width: usize,
    height: usize,
    field: YiqField,
) {
    ntscrs_yiq_write_to_strided_buffer_generic::<Xrgb8>(
        src_yiq, dst_data, blit_info, width, height, field,
    )
}
